<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="keywords" content="JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="赵斐昊">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="赵斐昊">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赵斐昊">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>赵斐昊</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?135474758d4e76a2244eb880e0faaf07";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赵斐昊</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个假程序员</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/BFC-块级格式化上下文/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/BFC-块级格式化上下文/" itemprop="url">BFC-块级格式化上下文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-10T17:19:19+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对BFC的理解"><a href="#对BFC的理解" class="headerlink" title="对BFC的理解"></a>对BFC的理解</h1><p>块级格式化上下文(BFC)，是CSS中的一个渲染机制，BFC就相当于一个盒子，内部的元素与外界的元素互不干扰。它不会影响外部的布局，外部的布局也不会影响到它.</p>
<h2 id="创建BFC"><a href="#创建BFC" class="headerlink" title="创建BFC"></a>创建BFC</h2><ul>
<li>float的值不是none</li>
<li>position 的值不是static或者relative</li>
<li>display的值是inline-block,table-cell,flex,table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ul>
<h2 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h2><ul>
<li>内部的BOX会在垂直方向上一个接一个的放置</li>
<li>于同一个BFC的俩个相邻的BOX的margin会发生重叠，与方向无关。</li>
<li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li>
<li>BFC的区域不会与float的元素区域重叠</li>
<li>计算BFC的高度时，浮动子元素也参与计算</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li>
</ul>
<h2 id="BFC在布局中的应用"><a href="#BFC在布局中的应用" class="headerlink" title="BFC在布局中的应用"></a>BFC在布局中的应用</h2><ul>
<li><p>防止margin重叠：<br>要阻止margin重叠，只要将俩个元素别放在一个BFC中即可</p>
</li>
<li><p>浮动相关问题<br>使得父元素包含子元素，常见的方式是为父元素设置overflow：hidden或者浮动父元素。根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题</p>
</li>
<li><p>多栏布局的一种方式<br>与浮动元素相邻的已生成BFC的元素不能与浮动元素互相覆盖。利用该特性可以作为多栏布局的一种实现方式.<br>特点在于左右俩栏的宽度固定，中间栏可以根据浏览器宽度自适应</p>
</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000013115595#articleHeader17" target="_blank" rel="noopener">参考：常用前端知识积累</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/08/html5和css3基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/html5和css3基础知识/" itemprop="url">html5和css3基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-08T17:01:13+08:00">
                2018-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="html5有哪些新特性，移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#html5有哪些新特性，移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="html5有哪些新特性，移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>html5有哪些新特性，移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h2><p><strong>新特性：</strong></p>
<ol>
<li><p>拖拽释放(Drag and drop) API</p>
</li>
<li><p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p>
</li>
<li><p>音频、视频API(audio,video)</p>
</li>
<li><p>画布(Canvas) API</p>
</li>
<li><p>地理(Geolocation) API</p>
</li>
<li><p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<a href="https://blog.csdn.net/u013628152/article/details/50269323" target="_blank" rel="noopener">参考博文</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/LocalStorage" target="_blank" rel="noopener">MDN</a></p>
</li>
<li><p>sessionStorage 的数据在浏览器关闭后自动删除</p>
</li>
<li><p>表单控件，calendar、date、time、email、url、search  </p>
</li>
<li><p>新的技术webworker, websocket, Geolocation</p>
</li>
</ol>
<p><strong>移除的元素：</strong></p>
<ol>
<li><p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p>
</li>
<li><p>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
</li>
</ol>
<p><strong>支持HTML5新标签：</strong></p>
<ol>
<li>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</strong><br>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；<br>本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除</p>
<p><strong>如何实现浏览器内多个标签页之间的通信?</strong><br>调用 localstorge、cookies 等本地存储方式</p>
<p><strong>新的 HTML5 文档类型和字符集是？</strong><br>HTML5文档类型：&lt;!doctype html&gt;</p>
<p>HTML5使用的编码<meta charset="”UTF-8”"></p>
<p><strong>HTML5 Canvas 元素有什么用</strong><br>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。</p>
<hr>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><p><strong>CSS3新特性</strong></p>
<ol>
<li><p>CSS3实现圆角（border-radius），阴影（box-shadow）</p>
</li>
<li><p>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</p>
</li>
<li><p>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜<br><a href="https://c.runoob.com/codedemo/3391" target="_blank" rel="noopener">示例</a></p>
</li>
<li><p>增加了更多的CSS选择器  多背景 rgba</p>
</li>
<li><p>在CSS3中唯一引入的伪元素是 ::selection.(::selection选择器匹配元素中被用户选中或处于高亮状态的部分。)</p>
</li>
<li><p>媒体查询，多栏布局</p>
</li>
<li><p>border-image</p>
</li>
</ol>
<p><strong>使用transform实现一个div旋转</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#myDiv</span> &#123;</span></span><br><span class="line"><span class="undefined">            width: 200px;</span></span><br><span class="line"><span class="undefined">            height: 200px;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#2f69b3</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">transform</span><span class="selector-pseudo">:rotate(10deg)</span>; </span></span><br><span class="line"><span class="css">            <span class="comment">/* transform:skew(20deg);  倾斜*/</span></span></span><br><span class="line"><span class="css">            <span class="comment">/* transform:scale(1.5); 放大 */</span></span></span><br><span class="line"><span class="css">            <span class="comment">/* transform:translate(120px,0); X轴右移，Y轴不动 */</span></span></span><br><span class="line"><span class="css">            <span class="comment">/* transform: rotateZ(30deg); */</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'myDiv'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var myDiv = document.getElementById('myDiv');</span></span><br><span class="line"><span class="undefined">        var t = 10;</span></span><br><span class="line"><span class="undefined">        setInterval(function()&#123;</span></span><br><span class="line"><span class="undefined">            myDiv.style.transform = `rotate($&#123;t++&#125;deg)`</span></span><br><span class="line"><span class="undefined">        &#125;,100)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>CSS3新增伪类</strong><br>p:first-of-type 选择属于其父元素的首个p元素的每个p元素。</p>
<p>p:last-of-type  选择属于其父元素的最后p元素的每个p元素。</p>
<p>p:only-of-type  选择属于其父元素唯一的p元素的每个p元素。</p>
<p>p:only-child    选择属于其父元素的唯一子元素的每个p元素。</p>
<p>p:nth-child(2)  选择属于其父元素的第二个子元素的每个p元素。</p>
<p>:enabled、:disabled 控制表单控件的禁用状态。</p>
<p>:checked，单选框或复选框被选中。</p>
<p><strong>40个重要的H5面试题</strong><br><a href="http://blog.jobbole.com/78346/" target="_blank" rel="noopener">参考</a></p>
<h1 id="其他一些HTML、css知识点"><a href="#其他一些HTML、css知识点" class="headerlink" title="其他一些HTML、css知识点"></a>其他一些HTML、css知识点</h1><p><strong>xhtml和html的区别</strong></p>
<blockquote>
<p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言<br>最主要的不同：<br>XHTML 元素必须被正确地嵌套。<br>XHTML 元素必须被关闭。<br>标签名必须用小写字母。<br>XHTML 文档必须拥有根元素。</p>
</blockquote>
<p><strong>盒子模型</strong></p>
<blockquote>
<p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域。4个部分一起构成了css中元素的盒模型。</p>
</blockquote>
<p><strong>对WEB标准以及W3C的理解与认识</strong></p>
<blockquote>
<p>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；</p>
</blockquote>
<p><strong>行内元素\块级元素\ 空(void)元素</strong></p>
<blockquote>
<p>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea<br>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote<br>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</p>
</blockquote>
<p><strong>CSS引入的方式有哪些? link和@import的区别</strong></p>
<blockquote>
<p>内联方式：指的是直接在 HTML 标签中的 style 属性中添加 CSS。<br>嵌入方式：指的是在 HTML 头部中的 &lt;style&gt; 标签下书写 CSS 代码。<br>链接方式：指的是使用 HTML 头部的 &lt;head&gt; 标签通过&lt;link href=‘xx.css’&gt;引入外部的 CSS 文件。<br>导入方式：指的是使用 CSS 规则引入外部 CSS 文件。@import url(style.css);</p>
<p>区别：<br>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>link支持使用Javascript控制DOM去改变样式；而@import不支持。</p>
</blockquote>
<p><strong>src与href的区别</strong></p>
<blockquote>
<p>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</p>
<p>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p>
</blockquote>
<p><strong>css属性的继承</strong><br>可以继承的属性很少，只有颜色，文字，字体间距、行高、对齐方式，和列表的样式可以继承。</p>
<blockquote>
<p>所有元素可继承：visibility和cursor。<br>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。<br>终端块状元素可继承：text-indent和text-align。<br>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。</p>
</blockquote>
<p><strong>同步和异步的区别</strong></p>
<blockquote>
<p>同步是阻塞模式，异步是非阻塞模式。<br>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；<br>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>
</blockquote>
<p><strong>px和em的区别</strong></p>
<blockquote>
<p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em</p>
</blockquote>
<p><strong>优雅降级和渐进增强</strong></p>
<blockquote>
<p>渐进增强 progressive enhancement：<br>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 graceful degradation：<br>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>区别：<br>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给<br>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要<br>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>
</blockquote>
<p><strong>display:none和visibility:hidden的区别</strong></p>
<blockquote>
<p>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p>
<p>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
</blockquote>
<p><strong>解释下浮动和它的工作原理？清除浮动的技巧</strong><br><a href="https://segmentfault.com/a/1190000004553339" target="_blank" rel="noopener">清除浮动方式总结</a></p>
<blockquote>
<p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p>1.使用空标签清除浮动。<br> 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。(浮动的元素，高度会塌陷,添加一个空div，利用CSS提供的clear:both清楚浮动，让父级div自动获取高度)<br>2.使用overflow。<br> 给包含浮动元素的父标签添加css属性 overflow:hidden; zoom:1; zoom:1用于兼容IE6。<br>3.使用after伪对象清除浮动。<br> 该方法只适用于非IE浏览器。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
</blockquote>
<p><strong>定位position详解:relative与absolute</strong></p>
<blockquote>
<p>position:relative; 如果对一个元素进行相对定位，首先它将出现在它所在的位置上。然后通过设置垂直或水平位置，让这个元素”相对于”它的原始起点进行移动。（再一点，相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框）</p>
<p>相对定位：relative 没有脱离正常的文档流，被设置元素相对于其原始位置而进行定位，其原始占位信息仍存在</p>
<p>position:absolute; 表示绝对定位，位置将依据浏览器左上角开始计算。 绝对定位使元素脱离文档流，因此不占据空间。普通文档流中元素的布局就像绝对定位的元素不存在时一样。（因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素并可以通过z-index来控制它层级次序。z-index的值越高，它显示的越在上层。）</p>
<p>绝对定位：ablution 脱离了文档流与浮动模型，独立于其他对象而存在，没有占位。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/关于React需要知道的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/关于React需要知道的/" itemprop="url">关于React需要知道的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T21:56:36+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于React需要知道的一些知识点"><a href="#关于React需要知道的一些知识点" class="headerlink" title="关于React需要知道的一些知识点"></a>关于React需要知道的一些知识点</h1><h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><p><img src="/images/react-life-circle.jpg" alt="React生命周期"></p>
<h2 id="调用-setState-之后发生了什么？"><a href="#调用-setState-之后发生了什么？" class="headerlink" title="调用 setState 之后发生了什么？"></a>调用 setState 之后发生了什么？</h2><blockquote>
<p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
</blockquote>
<h2 id="React-中-Element-与-Component-的区别是？"><a href="#React-中-Element-与-Component-的区别是？" class="headerlink" title="React 中 Element 与 Component 的区别是？"></a>React 中 Element 与 Component 的区别是？</h2><p>简单而言，React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为createElement的调用组合。而 React Component 则是可以接收参数输入并且返回某个 React Element 的函数或者类。</p>
<h2 id="在什么情况下你会优先选择使用-Class-Component-而不是-Functional-Component？"><a href="#在什么情况下你会优先选择使用-Class-Component-而不是-Functional-Component？" class="headerlink" title="在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？"></a>在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？</h2><p>在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。</p>
<h2 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h2><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CustomForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中的input域包含了一个ref属性，该属性声明的回调函数会接收input对应的 DOM 元素，我们将其绑定到this指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="React-中-key-的作用是什么？"><a href="#React-中-key-的作用是什么？" class="headerlink" title="React 中 key 的作用是什么？"></a>React 中 key 的作用是什么？</h2><blockquote>
<p>Key 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p>
</blockquote>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><blockquote>
<p>把树形结构按照层级分解，只比较同级元素。<br>给列表结构的每个单元添加唯一的key属性，方便比较。<br>React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.<br>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。<br><a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">参考链接</a></p>
</blockquote>
<h2 id="如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？"><a href="#如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？" class="headerlink" title="如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？"></a>如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">// fetchUser take in a username returns a promise</span><br><span class="line">// which will resolve with that username&apos;s data.</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  // finish this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以<code>props.children</code>进行调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: null,</span><br><span class="line">  &#125;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(this.props.username)</span><br><span class="line">      .then((user) =&gt; this.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return this.props.children(this.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过Props传递，这样父组件能够更为方便地控制子组件展示的UI界面。譬如产品经理让我们将原本展示的Badge替换为Profile，我们可以轻易地修改下回调函数即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Profile info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Controlled-Component-与-Uncontrolled-Component-之间的区别"><a href="#Controlled-Component-与-Uncontrolled-Component-之间的区别" class="headerlink" title="Controlled Component 与 Uncontrolled Component 之间的区别"></a>Controlled Component 与 Uncontrolled Component 之间的区别</h2><p>受控组件（Controlled Component）代指那些交由 React 控制并且所有的表单数据统一存放的组件。譬如下面这段代码中username变量值并没有存放到DOM元素中，而是存放在组件状态数据中。任何时候我们需要改变username变量值时，我们应当调用setState函数进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ControlledForm extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    username: &apos;&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  updateUsername = (e) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      username: e.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleSubmit = () =&gt; &#123;&#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          value=&#123;this.state.username&#125;</span><br><span class="line">          onChange=&#123;this.updateUsername&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而非受控组件（Uncontrolled Component）则是由DOM存放表单数据，并非存放在 React 组件中。我们可以使用 refs 来操控DOM元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class UnControlledForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>竟然非受控组件看上去更好实现，我们可以直接从 DOM 中抓取数据，而不需要添加额外的代码。不过实际开发中我们并不提倡使用非受控组件，因为实际情况下我们需要更多的考虑表单验证、选择性的开启或者关闭按钮点击、强制输入格式等功能支持，而此时我们将数据托管到 React 中有助于我们更好地以声明式的方式完成这些功能。引入 React 或者其他 MVVM 框架最初的原因就是为了将我们从繁重的直接操作 DOM 中解放出来。</p>
<h2 id="在生命周期中的哪一步你应该发起-AJAX-请求"><a href="#在生命周期中的哪一步你应该发起-AJAX-请求" class="headerlink" title="在生命周期中的哪一步你应该发起 AJAX 请求?"></a>在生命周期中的哪一步你应该发起 AJAX 请求?</h2><blockquote>
<p>React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</p>
<p>如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。</p>
</blockquote>
<h2 id="如何告诉-React-它应该编译生产环境版本？"><a href="#如何告诉-React-它应该编译生产环境版本？" class="headerlink" title="如何告诉 React 它应该编译生产环境版本？"></a>如何告诉 React 它应该编译生产环境版本？</h2><blockquote>
<p>通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息。</p>
</blockquote>
<h2 id="为什么我们需要使用-React-提供的-Children-API-而不是-JavaScript-的-map？"><a href="#为什么我们需要使用-React-提供的-Children-API-而不是-JavaScript-的-map？" class="headerlink" title="为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？"></a>为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？</h2><p><code>props.children</code>并不一定是数组类型，譬如下面这个元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;h1&gt;Welcome.&lt;/h1&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果我们使用<code>props.children.map</code>函数来遍历时会受到异常提示，因为在这种情况下<code>props.children</code>是对象（object）而不是数组（array）。React 当且仅当超过一个子元素的情况下会将<code>props.children</code>设置为数组，就像下面这个代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Parent&gt;</span><br><span class="line">  &lt;h1&gt;Welcome.&lt;/h1&gt;</span><br><span class="line">  &lt;h2&gt;props.children will now be an array&lt;/h2&gt;</span><br><span class="line">&lt;/Parent&gt;</span><br></pre></td></tr></table></figure></p>
<p>这也就是我们优先选择使用<code>React.Children.map</code>函数的原因，其已经将<code>props.children</code>不同类型的情况考虑在内了。</p>
<h2 id="概述下-React-中的事件处理逻辑"><a href="#概述下-React-中的事件处理逻辑" class="headerlink" title="概述下 React 中的事件处理逻辑"></a>概述下 React 中的事件处理逻辑</h2><blockquote>
<p>为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。</p>
</blockquote>
<h2 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a>createElement 与 cloneElement 的区别是什么？</h2><blockquote>
<p>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。</p>
</blockquote>
<h2 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a>传入 setState 函数的第二个参数的作用是什么？</h2><p>该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.setState(</span><br><span class="line">  &#123; username: &apos;tylermcginnis33&apos; &#125;,</span><br><span class="line">  () =&gt; console.log(&apos;setState has finished and the component has re-rendered.&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="react性能优化方案"><a href="#react性能优化方案" class="headerlink" title="react性能优化方案"></a>react性能优化方案</h2><ol>
<li><p>重写shouldComponentUpdate来避免不必要的dom操作。</p>
</li>
<li><p>使用 production 版本的react.js。</p>
</li>
<li><p>使用key来帮助React识别列表中所有子组件的最小变化。</p>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000008102870" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/箭头函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/箭头函数/" itemprop="url">箭头函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T21:27:42+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ES6中箭头函数与普通函数的区别"><a href="#ES6中箭头函数与普通函数的区别" class="headerlink" title="ES6中箭头函数与普通函数的区别"></a>ES6中箭头函数与普通函数的区别</h1><p>箭头函数就是没有function关键字，而是一个类似箭头的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两者区别在于：</p>
<ol>
<li><p><strong>箭头函数作为匿名函数,是不能作为构造函数的,不能使用new</strong></p>
</li>
<li><p><strong>箭头函数不绑定arguments,取而代之用rest参数…解决</strong></p>
</li>
<li><p><strong>箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值</strong></p>
</li>
<li><p><strong>箭头函数当方法使用的时候没有定义this绑定</strong></p>
</li>
<li><p><strong>使用call()和apply()调用，对this并没有什么影响</strong></p>
</li>
<li><p><strong>箭头函数没有原型属性</strong></p>
</li>
<li><p><strong>箭头函数不能当做Generator函数,不能使用yield关键字</strong></p>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/73cbeb6782a0" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/Promise/" itemprop="url">Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T21:02:36+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于Promise需要知道的"><a href="#关于Promise需要知道的" class="headerlink" title="关于Promise需要知道的"></a>关于Promise需要知道的</h1><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><blockquote>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理，让开发者不用再关注于时序和底层的结果。Promise的状态具有不受外界影响和不可逆两个特点。</p>
</blockquote>
<h2 id="传统的回调式异步操作有什么缺点？（Promise是如何解决异步操作）"><a href="#传统的回调式异步操作有什么缺点？（Promise是如何解决异步操作）" class="headerlink" title="传统的回调式异步操作有什么缺点？（Promise是如何解决异步操作）"></a>传统的回调式异步操作有什么缺点？（Promise是如何解决异步操作）</h2><ol>
<li>调用回调过早</li>
<li>调用回调过晚（或没有被调用）</li>
<li>调用回调次数过少或过多</li>
<li>未能传递所需的环境和参数</li>
<li>吞掉可能出现的错误和异常</li>
</ol>
<p>Promise的解决办法：</p>
<ol>
<li>调用回调过早</li>
</ol>
<p>对于Promise来说，即使是立即完成的Promise也无法被同步观察到，也就是说一个Promise调用then()的时候，即使这个Promise已经决议了，提供给then的回调也总会被异步调用。</p>
<ol>
<li>调用回调过晚（或没有被调用）</li>
</ol>
<p>对于一个Promise对象注册的每一个观察回调都是相对独立、互不干预的。而Promise对象调用resolve()和reject()时，每个注册的观察回调也都会被自动调度。所以这些观察回调的任意一个都无法影响或延误对其他回调的调用。</p>
<ol>
<li>调用回调次数过少或过多</li>
</ol>
<p>Promise的定义方式使得它只能被决议一次。即使代码中出现多次决议，这个Promise也会接受第一次决议，并会忽略掉其他任何后续调用。所以任何通过then()注册的回调只会被调用一次。</p>
<ol>
<li>未能传递所需的环境和参数</li>
</ol>
<p>凡是被决议的值都会传递到观察回调中，如果没有显示的决议值也会传递一个undefined给观察回调。需要注意的是，Promise只允许传一个决议值，其他值将会被默默忽略掉。</p>
<ol>
<li>吞掉可能出现的错误和异常</li>
</ol>
<p>如果在创建Promise时，存在JavaScript代码错误，会直接导致该Promise的拒绝决议，那么你可以通过reject()来捕获异常，代码中的任何异常都不会吞掉。</p>
<h2 id="Promise中的异步模式有哪些？有什么区别？"><a href="#Promise中的异步模式有哪些？有什么区别？" class="headerlink" title="Promise中的异步模式有哪些？有什么区别？"></a>Promise中的异步模式有哪些？有什么区别？</h2><p>也就是在问，Promise.all()和Promise.race()的区别</p>
<blockquote>
<p>all会将传入的数组中的所有promise全部决议以后，将决议值以数组的形式传入到观察回调中，任何一个promise决议为拒绝，那么就会调用拒绝回调。</p>
<p>race会将传入的数组中的所有promise中第一个决议的决议值传递给观察回调，即使决议结果是拒绝。</p>
</blockquote>
<h2 id="如果向Promise-all-和Promise-race-传递空数组，运行结果会有什么不同？"><a href="#如果向Promise-all-和Promise-race-传递空数组，运行结果会有什么不同？" class="headerlink" title="如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？"></a>如果向Promise.all()和Promise.race()传递空数组，运行结果会有什么不同？</h2><p>all会立即决议，决议结果是fullfilled，值是undefined</p>
<p>race会永远都不决议，程序卡死……</p>
<h2 id="如何确保一个变量是可信任的Promise（Promise-resolve方法传入不同值的不同处理有哪些）"><a href="#如何确保一个变量是可信任的Promise（Promise-resolve方法传入不同值的不同处理有哪些）" class="headerlink" title="如何确保一个变量是可信任的Promise（Promise.resolve方法传入不同值的不同处理有哪些）"></a>如何确保一个变量是可信任的Promise（Promise.resolve方法传入不同值的不同处理有哪些）</h2><p>可以通过Promise.resolve()方法对不确定的值进行Promise化，返回一个Promise对象。</p>
<p>如果是一个立即值，如一个普通变量，那么该Promise会立即决议为成功。</p>
<p>如果是一个Promise值，那么会将该Promise直接返回赋值给这个Promise，不会有额外开销。</p>
<p>如果是一个类Promise值， 比如其中含有名称为then的成员变量，那么会将then展开形成一个新的Promise对象。</p>
<h2 id="Promise是如何捕获异常的？与传统的try-catch相比有什么优势？"><a href="#Promise是如何捕获异常的？与传统的try-catch相比有什么优势？" class="headerlink" title="Promise是如何捕获异常的？与传统的try/catch相比有什么优势？"></a>Promise是如何捕获异常的？与传统的try/catch相比有什么优势？</h2><p>传统的try/catch捕获异常方式是无法捕获异步的异常的.<br>而对于Promise对象来说，构造Promise实例时的代码如果出错，则会被认为是一个拒绝的决议，并会向观察回调中传递异常信息。所以即使是一个异步的请求，Promise也是可以捕获异常的。此外，Promise还可以通过catch回调来捕获回调中的异常。</p>
<p><a href="https://zhuanlan.zhihu.com/p/29235579" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/css3实现垂直居中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/css3实现垂直居中/" itemprop="url">css3实现垂直居中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T20:34:18+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="css3实现垂直居中的三种方法"><a href="#css3实现垂直居中的三种方法" class="headerlink" title="css3实现垂直居中的三种方法"></a>css3实现垂直居中的三种方法</h1><p>目标：垂直居中main块<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Am I centered yet?<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Center me, please!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="方法一：通过绝对定位实现"><a href="#方法一：通过绝对定位实现" class="headerlink" title="方法一：通过绝对定位实现"></a>方法一：通过绝对定位实现</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝对定位的top: 50%; left: 50%将main块的左上角定位到main块父节点（即body元素）的中心点，也就是页面的中心点。transform translate移位变换，当位移值是百分数时，是相对于当前块的尺寸大小的。因此main块在X轴向左位移本身宽度的50%，在Y轴向上位移本身高度的50%后，恰当使main块在当前页面垂直中心。</p>
<h2 id="方法二：通过viewport相关尺寸单位实现"><a href="#方法二：通过viewport相关尺寸单位实现" class="headerlink" title="方法二：通过viewport相关尺寸单位实现"></a>方法二：通过viewport相关尺寸单位实现</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">18em</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50vh</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1vh是viewport高度的1%，50vh指viewport高度的50%；相应的，1vw是viewport宽度的1%。通过设置main块的上边距margin-top值为50vh，使main块的上边沿正好在页面的垂直方向的等分线上的。而左右边距都为auto，实现了main块在水平方向上居中。再通过与方法一中一样的移位方法，使main块在当前页面上垂直居中。需要注意的是，<strong>要使用这种方法，main块的宽度width值必需要设置。</strong></p>
<h2 id="方法三：通过flex布局实现"><a href="#方法三：通过flex布局实现" class="headerlink" title="方法三：通过flex布局实现"></a>方法三：通过flex布局实现</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要对main块进行flex布局，需要将display: flex的属性值设置在main块的父节点（即body元素)上，同时还要设置最小高度值为viewport的高度值。之后只要简单main块的页边距为auto，就自动实现垂直和水平方向上的自动居中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/javascript内存泄漏及如何避免/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/javascript内存泄漏及如何避免/" itemprop="url">JavaScript内存泄漏及如何避免</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T18:53:02+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JavaScript-内存泄露及如何避免"><a href="#JavaScript-内存泄露及如何避免" class="headerlink" title="JavaScript 内存泄露及如何避免"></a>JavaScript 内存泄露及如何避免</h1><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>本质上，内存泄露可以定义为：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。</p>
<h2 id="JavaScript-内存管理"><a href="#JavaScript-内存管理" class="headerlink" title="JavaScript 内存管理"></a>JavaScript 内存管理</h2><p>JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有开发者了解哪些内存在将来仍会使用，而不可达内存通过算法确定和标记，适时被操作系统回收。<br><em>程序员也要在编程时注意，一旦数据不再有用，最好通过将其值设置为null来释放其引用，这个做法叫解除引用。</em></p>
<h2 id="JavaScript垃圾收集"><a href="#JavaScript垃圾收集" class="headerlink" title="JavaScript垃圾收集"></a>JavaScript垃圾收集</h2><p>原理：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔周期性执行这一操作。<br>通常有两个策略实现：</p>
<ol>
<li><p><strong>标记清除</strong></p>
<blockquote>
<p>当变量进入环境时，将这个变量记为‘进入环境’。逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为‘离开环境’。</p>
</blockquote>
</li>
<li><p><strong>引用计数</strong></p>
<blockquote>
<p>跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对这个值的引用的变量又取得了另外一个值，则这个值的引用次数减1，当这个值的引用次数变成0时，则说明没法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
</blockquote>
</li>
</ol>
<h2 id="几种常见的JavaScript内存泄漏"><a href="#几种常见的JavaScript内存泄漏" class="headerlink" title="几种常见的JavaScript内存泄漏"></a>几种常见的JavaScript内存泄漏</h2><h3 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h3><p>JavaScript 处理未定义变量的方式比较宽松：未定义的变量会在全局对象创建一个新变量。在浏览器中，全局对象是 <code>window</code> 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    bar = <span class="string">"this is a hidden global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真相是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.bar = <span class="string">"this is an explicit global variable"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有更糟的情况,全局变量可能由 this 创建:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.variable = <span class="string">"potential accidental global"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在 JavaScript 文件头部加上 ‘use strict’，可以避免此类错误发生。启用严格模式解析 JavaScript ，避免意外的全局变量。</p>
</blockquote>
<p><strong>全局变量注意事项</strong></p>
<p>尽管我们讨论了一些意外的全局变量，但是仍有一些明确的全局变量产生的垃圾。它们被定义为不可回收（除非定义为空或重新分配）。尤其当全局变量用于临时存储和处理大量信息时，需要多加小心。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。</p>
<h3 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h3><p>在 JavaScript 中使用 setInterval 非常平常。一段常见的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = getData();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'Node'</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        node.innerHTML = <span class="built_in">JSON</span>.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>此例说明：与节点或数据关联的计时器不再需要，node 对象可以删除，整个回调函数也不需要了。可是，计时器回调函数仍然没被回收（计时器停止才会被回收）。同时，someResource 如果存储了大量的数据，也是无法被回收的。</p>
<p>对于观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。如今，即使没有明确移除它们，一旦观察者对象变成不可达，大部分浏览器是可以回收观察者处理函数的。</p>
<h3 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h3><p>有时，保存 DOM 节点内部数据结构很有用。假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">    button: <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>),</span><br><span class="line">    image: <span class="built_in">document</span>.getElementById(<span class="string">'image'</span>),</span><br><span class="line">    text: <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    image.src = <span class="string">'http://some.url/image'</span>;</span><br><span class="line">    button.click();</span><br><span class="line">    <span class="built_in">console</span>.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'button'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是 JavaScript 开发的一个关键方面：匿名函数可以访问父级作用域的变量。</p>
<p>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/重绘和重排/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/重绘和重排/" itemprop="url">重绘和重排</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T16:56:12+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="影响浏览器重绘和重排"><a href="#影响浏览器重绘和重排" class="headerlink" title="影响浏览器重绘和重排"></a>影响浏览器重绘和重排</h1><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>
<h2 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h2><p>浏览器下载完页面中的所有资源（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM树和渲染树），DOM树表示页面结构，渲染树表示DOM节点如何显示。重排是DOM元素的几何属性变化，DOM树的结构变化，渲染树需要重新计算。</p>
<h2 id="重绘和重排的关系"><a href="#重绘和重排的关系" class="headerlink" title="重绘和重排的关系"></a>重绘和重排的关系</h2><p>重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</p>
<h2 id="什么情况下会触发重排？"><a href="#什么情况下会触发重排？" class="headerlink" title="什么情况下会触发重排？"></a>什么情况下会触发重排？</h2><ol>
<li>页面渲染初始化时；（这个无法避免）</li>
<li>浏览器窗口改变尺寸；</li>
<li>元素尺寸改变时；</li>
<li>元素位置改变时；</li>
<li>元素内容改变时；</li>
<li>添加或删除可见的DOM 元素时。</li>
</ol>
<h2 id="重排优化有如下五种方法"><a href="#重排优化有如下五种方法" class="headerlink" title="重排优化有如下五种方法"></a>重排优化有如下五种方法</h2><ol>
<li>将多次改变样式属性的操作合并成一次操作，减少DOM访问。</li>
<li>如果要批量添加DOM，可以先让元素脱离文档流，操作完后再带入文档流，这样只会触发一次重排。（fragment元素的应用）</li>
<li>将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</li>
<li>由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次重排。</li>
<li>在内存中多次操作节点，完成后再添加到文档中去。例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。</li>
</ol>
<p><a href="http://www.cnblogs.com/yuri2016/p/6542625.html" target="_blank" rel="noopener">参考</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/从输入URL到页面显示经历了什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/从输入URL到页面显示经历了什么/" itemprop="url">从输入URL到页面显示经历了什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T15:41:57+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从输入网址到页面呈现都发生了什么？"><a href="#从输入网址到页面呈现都发生了什么？" class="headerlink" title="从输入网址到页面呈现都发生了什么？"></a>从输入网址到页面呈现都发生了什么？</h1><h2 id="简洁版"><a href="#简洁版" class="headerlink" title="简洁版"></a>简洁版</h2><p>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；<br>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；<br>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；<br>载入解析到的资源文件，渲染页面，完成。</p>
<h2 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h2><p>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>进行HTTP协议会话，客户端发送报头(请求报头);<br>进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
<h2 id="超详细版"><a href="#超详细版" class="headerlink" title="超详细版"></a>超详细版</h2><p><a href="https://www.cnblogs.com/jesse131/p/6215961.html" target="_blank" rel="noopener">超详细解析可直接跳转到这篇博文</a></p>
<h2 id="超详细版的精简说法"><a href="#超详细版的精简说法" class="headerlink" title="超详细版的精简说法"></a>超详细版的精简说法</h2><p><strong>从输入网址到页面呈现这个过程大致可分为<code>网络通信</code>和<code>页面渲染</code>两个部分</strong></p>
<p><strong>网络通信</strong></p>
<ol>
<li>应用层中的DNS服务负责对输入的网址进行域名查询与解析。</li>
<li>应用层中客户端发送HTTP请求报文。</li>
<li>经过传输层，TCP协议确保传输报文可靠性。将大块的数据分割成以报文段，进行三次握手。</li>
<li>经过网络层。IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址。</li>
<li>经过链路层，硬件部分负责传输数据。在网络层找到对方的MAC地址后，就将数据发送到数据链路层传输。至此请求报文已发出。</li>
<li>服务器接收报文。接收端服务器在链路层接收到数据后，逐层向上将数据传递到应用层，逐层去掉首部信息，至此数据传输到应用层才能算真正接收到由客户端发送过来的HTTP请求。</li>
<li>服务器在应用层发送HTTP响应报文。响应原路返回。</li>
</ol>
<blockquote>
<p>在网络通信阶段对前端优化建议：<br>减少HTTP请求数、避免重定向、cookie优化、启用GZIP压缩、使用CDN加速、合理利用HTTP缓存(通过设置Expires)</p>
</blockquote>
<p><strong>页面渲染</strong><br>客户端在接收到html代码之后，接下来的流程如下：</p>
<ol>
<li>解析html以构建DOM树。</li>
<li>浏览器会在构建DOM树的同时构建render树,呈现树的每一个节点即为与其相对应的DOM节点的CSS框。</li>
<li>布局render树。在创建render树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</li>
<li>绘制render树。在绘制阶段，系统会遍历render树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。</li>
<li>页面变化造成的影响。在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</li>
</ol>
<blockquote>
<p>在页面渲染阶段对前端优化建议：<br>建议将 CSS 文件放在页首，以便构建 DOM 树；而将 JavaScript 文件尽量放在页面下方，防止阻塞构建 DOM 树；而 JavaScript 的 onload 事件里，不要写太多影响首屏渲染的、操作 DOM 树的 JavaScript 代码。<br>精简 JavaScript 和 CSS 代码，并进行代码压缩，使得css和js资源更快的下载<br>编写高效的CSS代码<br>重要的图片或者想让用户优先看到的图片使用img标签，次要的图片使用background引入</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/前端性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赵斐昊">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵斐昊">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/前端性能优化/" itemprop="url">前端性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T10:30:33+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前端性能优化的几个知识点"><a href="#前端性能优化的几个知识点" class="headerlink" title="前端性能优化的几个知识点"></a>前端性能优化的几个知识点</h1><h2 id="如何进行页面重构"><a href="#如何进行页面重构" class="headerlink" title="如何进行页面重构"></a>如何进行页面重构</h2><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>
<blockquote>
<p><strong>对于传统的网站来说重构通常是</strong><br>表格(table)布局改为DIV+CSS<br>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)<br>对于移动平台的优化<br>针对于SEO进行优化</p>
<p><strong>深层次的网站重构应该考虑的方面</strong><br>减少代码间的耦合<br>让代码保持弹性<br>严格按规范编写代码<br>设计可扩展的API<br>代替旧有的框架、语言(如VB)<br>增强用户体验</p>
<p><strong>通常来说对于速度的优化也包含在重构中</strong><br>压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>程序的性能优化(如数据读写)<br>采用CDN来加速资源加载<br>对于JS DOM的优化<br>HTTP服务器的文件缓存</p>
</blockquote>
<h2 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h2><blockquote>
<p><strong>优雅降级</strong><br>Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：border-shadow</p>
<p><strong>渐进增强</strong><br>从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p>
</blockquote>
<h2 id="前端性能优化的方法"><a href="#前端性能优化的方法" class="headerlink" title="前端性能优化的方法"></a>前端性能优化的方法</h2><p><strong>简洁明了版说法</strong></p>
<ol>
<li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li>
<li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li>
<li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li>
<li>当需要设置的样式很多时设置className而不是直接操作style。</li>
<li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</li>
<li>避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。</li>
<li>避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。</li>
</ol>
<p>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</p>
<p><strong>较真版说法</strong></p>
<p>浏览器请求处理流程图<br><img src="/images/performance_optimaze.png" alt="浏览器请求处理流程图"></p>
<ol>
<li><p>减少HTTP请求<br> http协议是 <strong>无状态</strong>的应用层协议，意味着 <strong>每次http请求都需要建立通信链路、进行数据传输</strong>，而 <strong>在服务器端每个http都需要启动独立的线程去处理</strong>。这些通信和服务的开销都很昂贵，减少http请求的数目可有效提高访问性能。</p>
<ul>
<li><strong>合并CSS、合并javascript、合并图片。</strong>将浏览器一次访问需要的javascript和CSS合并成一个文件，这样浏览器就只需要一次请求。图片也可以合并，多张图片合并成一张，如果每张图片都有不同的超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL。</li>
<li><strong>合理设置缓存。</strong>很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。</li>
</ul>
</li>
<li><p>使用浏览器缓存</p>
<ul>
<li><strong>将更新频率比较低的CSS、javascript、logo、图标等静态资源文件缓存在浏览器中</strong>，避免频繁的http请求。通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以是数天，甚至是几个月。</li>
<li>当静态资源文件发生变化时，通过 <strong>生成一个新的JS文件并更新HTML文件中的引用来更新js文件</strong>，避免直接更新js文件中的内容。</li>
<li>使用浏览器缓存策略的网站在更新静态资源时，应采用 <strong>逐量更新</strong>的方法，比如需要更新10个图标文件，不宜把10个文件一次全部更新，而是应该一个文件一个文件逐步更新，并有一定的间隔时间，避免用户浏览器忽然大量缓存失效，集中更新缓存，造成服务器负载骤增、网络堵塞的情况。</li>
</ul>
</li>
<li><p>启用压缩<br><strong>在服务器端对文件进行压缩，在浏览器端对文件解压缩</strong>可有效减少通信传输的数据量。如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。文本文件的压缩效率可达到80%以上，因此HTML、CSS、javascript文件启用GZip压缩可达到较好的效果。但是压缩对服务器和浏览器产生一定的压力，在通信带宽良好，而服务器资源不足的情况下要权衡考虑。</p>
</li>
<li><p>CSS Sprites<br>合并CSS图片，减少HTTP请求数。</p>
</li>
<li><p>LazyLoad Images<br>这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。</p>
</li>
<li><p>CSS放在页面最上部，javascript放在页面最下面<br>浏览器会在下载完成全部CSS之后才对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕，所以可以考虑将CSS放在HEAD中。<br>Javascript则相反，浏览器在加载javascript后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此javascript最好放在页面最下面。但如果页面解析时就需要用到javascript，这时放到底部就不合适了。</p>
</li>
<li><p>Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）<br>随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费-既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。</p>
</li>
<li><p>异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）<br>在某些页面中可能存在这样一种需求，需要使用 script标签来异步的请求数据,直接在页面上写 &lt;script&gt; .<br>这样对页面的性能也是有影响的，即增加了页面首次加载的负担，推迟了 DOMLoaded和window.onload 事件的触发时机。如果时效性允许的话，可以考虑在 DOMLoaded事件触发的时候加载，或者使用 setTimeout方式来灵活的控制加载的时机。</p>
</li>
<li><p>减少cookie传输<br>一方面，cookie包含在每次请求和响应中，太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中传输的数据量。另一方面，对于某些静态资源的访问，如CSS、script等，发送cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie，减少cookie传输次数。</p>
</li>
<li><p>Javascript代码优化</p>
<ul>
<li>DOM<br><strong>HTML Collection（HTML收集器，返回的是一个数组内容信息）</strong><br>在脚本中 document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的“访问集合” 包括读取集合的 length属性、访问集合中的元素。</li>
</ul>
<p>因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问(Array.prototype.slice.call(HTMLCollection))，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。</p>
<p><strong>Reflow &amp; Repaint</strong><br>DOM操作还需要考虑浏览器的Reflow和Repaint ，因为这些都是需要消耗资源的。</p>
<ul>
<li>慎用 with　<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(obj)&#123; p = <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>代码块的行为实际上是修改了代码块中的执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。</p>
<p>因此，<strong>除非你能肯定在 with代码中只访问 obj中的属性</strong>，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</p>
<ul>
<li>避免使用 eval和 Function</li>
</ul>
<p>每次 eval或Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。</p>
<p>eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。</p>
<p>Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。</p>
<p>此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。</p>
<ul>
<li>减少作用域链查找</li>
</ul>
<p>前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。此外，要减少作用域链查找还应该减少闭包的使用。</p>
<ul>
<li>数据访问<br>　　Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：<br>a. 对任何对象属性的访问超过 1次<br>b. 对任何数组成员的访问次数超过 1次</li>
</ul>
<p>另外，还应当尽可能的减少对对象以及数组深度查找。</p>
<ul>
<li><p>字符串拼接<br>在 Javascript中使用”+”号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。</p>
</li>
<li><p>CSS选择符优化<br>在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#toc</span> <span class="selector-tag">A</span> &#123; <span class="attribute">color</span>: <span class="number">#444</span>; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样一个选择符，如果是从左往右解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项。</p>
<ul>
<li>CDN加速<br>CDN（contentdistribute network，内容分发网络）的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据，即所谓网络访问第一跳。<br>由于CDN部署在网络运营商的机房，这些运营商又是终端用户的网络服务提供商，因此用户请求路由的第一跳就到达了CDN服务器，当CDN中存在浏览器请求的资源时，从CDN直接返回给浏览器，最短路径返回响应，加快用户访问速度，减少数据中心负载压力。<br>CDN缓存的一般是静态资源，如图片、文件、CSS、script脚本、静态网页等，但是这些文件访问频度很高，将其缓存在CDN可极大改善网页的打开速度。</li>
</ul>
</li>
<li><p>反向代理<br>传统代理服务器位于浏览器一侧，代理浏览器将http请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站web服务器接收http请求。<br>论坛网站，把热门词条、帖子、博客缓存在反向代理服务器上加速用户访问速度，当这些动态内容有变化时，通过内部通知机制通知反向代理缓存失效，反向代理会重新加载最新的动态内容再次缓存起来。<br>此外，反向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以提高系统总体处理能力，进而改善网站高并发情况下的性能。</p>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/833a5fad8b08" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/qq_42375089/article/details/80863723" target="_blank" rel="noopener">参考2</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">赵斐昊</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵斐昊</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
<script type="text/javascript" src="/js/src/love.js"></script>
</html>
